# -*- coding: utf-8 -*-
"""ApplStock.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nZ9xuzIRKJ4onG-6qycVbGLbiK0iHWHJ
"""

import numpy as np
import pandas_datareader as pdr
import pandas as pd
from datetime import datetime
import warnings
warnings.filterwarnings("ignore")

df= pd.read_csv("/content/AAPL.csv")
df

df.isna().sum()

df.info()

df["Date"]=pd.to_datetime(df["Date"])

data=df.set_index(["Date"])
data

# Commented out IPython magic to ensure Python compatibility.
import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline

fig, axes = plt.subplots(figsize=(20,12))

sns.lineplot(data.index, data['Open'],label='Open')
sns.lineplot(data.index, data['Close'],label='Close')
sns.lineplot(data.index, data['High'],label='High')
sns.lineplot(data.index, data['Low'],label='Low')
sns.lineplot(data.index, data['Adj Close'],label='Adj Close')

data['Close'].plot(figsize=(18,6))

"""#Time Resampling"""

data.resample(rule= 'A').max()

data.resample(rule= 'A').max().plot()

"""#Quarterly"""

data.resample(rule= 'A').max()['Close'].plot()

data.resample(rule= 'M').max()['Close'].plot()

data.resample(rule= 'Q').mean()['Close'].plot(kind="line")

import matplotlib.pyplot as plt

"""#checking  Distribution of our Data"""

fig = plt.figure(figsize=(10,8))
sns.distplot(data['Close']).set_title("Distribution Plot Close AAPL")
plt.tick_params(labelsize=12)
sns.set(font_scale=1)
plt.xticks(fontsize=16)
plt.yticks(fontsize=16)

from statsmodels.graphics.gofplots import qqplot as qq

qq_plot = qq(data['Close'],line='s')
plt.title('QQ Plot Apple Stock Price')

log_close = np.log(data["Close"])
sqrt_close = np.sqrt(data['Close'])

##Checking Distribution of Our Data 
fig = plt.figure(figsize=(10,8))
sns.distplot(log_close)

plt.xticks(fontsize=16)
plt.yticks(fontsize=16)

##Checking Distribution of Our Data 
fig = plt.figure(figsize=(10,8))
sns.distplot(sqrt_close)

plt.xticks(fontsize=16)
plt.yticks(fontsize=16)

"""#Converting 'Date' to datetime object"""

df['Date'] = pd.to_datetime(df['Date'])
df['Year'] = df['Date'].dt.year
df['Month'] = df['Date'].dt.month
df['Quarter'] = df['Date'].dt.quarter

df

df.describe()

data=df.copy()
data

"""We can see the trend than a cyclic behavior. We can see the price is increasing yearly"""

# Plot Daily Volume Lineplot
fig, ax = plt.subplots(figsize=(18, 6))
sns.lineplot(data['Date'], data['Volume'] )

"""#Aggregating the Time Series to a Monthly scaled Index"""

y = data[['Date','Volume']].copy()
y.set_index('Date', inplace=True)
y.index = pd.to_datetime(y.index)
y = y.resample('1M').mean()
y['Date'] = y.index

# Plot the Monthly Volume Lineplot
fig, ax = plt.subplots(figsize=(15, 6))
sns.lineplot(y['Date'], y['Volume'] )

ax.set_title('Monthly Volume', fontsize = 15, loc='center')
ax.set_xlabel('Year', fontsize = 12)
plt.tick_params(axis='y', which='major', labelsize=12)
plt.tick_params(axis='x', which='major', labelsize=12)

data['Year'].unique()

variable = 'Close'
fig, ax = plt.subplots(figsize=(18, 6))

sns.lineplot(data['Month'], data[variable], hue = data['Year'])
ax.set_title('Seasonal plot of Price', fontsize = 15)

fig, ax = plt.subplots(figsize=(20,10))
palette = sns.color_palette("mako_r", 4)
a = sns.barplot(x="Year", y="Close",hue = 'Quarter',data= data)
a.set_title("Stock Prices Year & Month Wise",fontsize=15)
plt.legend(loc='upper left')
plt.show()

fig, ax = plt.subplots(figsize=(20,10))
palette = sns.color_palette("mako_r", 4)
a = sns.barplot(x="Quarter", y="Close",hue = 'Year',data= data)
a.set_title("Stock Prices Year & Month Wise",fontsize=15)
plt.legend(loc='upper left')
plt.show()

from statsmodels.graphics.tsaplots import quarter_plot

# Using quarter_plot to plot the mean of the prices.
df=data.copy()
df.set_index(["Date"],inplace=True)
quarter_plot(df['Close'].resample('Q').mean())
plt.title('Mean Adjsuted Price v/s Quarters')
plt.xlabel('Quarters')
plt.ylabel('Mean Adjusted Price')
plt.show()

import altair as alt
import numpy as np
import pandas as pd

alt.Chart(data).mark_line(
    point=True
).encode(
    x='Month',
    y='Close',
    column = 'Year'
     
).properties(
    title="Sales: Yearly Subseries plot",
    width=100).configure_header(
    titleColor='black',
    titleFontSize=14,
    labelColor='blue',
    labelFontSize=14
)

alt.Chart(data).mark_line(
    point=True
).encode(
    x='Year',
    y='Close',
    column = 'Quarter'
     
).properties(
    title="Sales: Yearly Subseries plot",
    width=100).configure_header(
    titleColor='black',
    titleFontSize=14,
    labelColor='blue',
    labelFontSize=14
)

sns.boxplot(data['Year'], data[variable])

sns.boxplot(data['Month'], data[variable])

# Aggregating the Time Series to a monthly scaled index
y = data[['Date','Open','Close']].copy()
y.set_index('Date', inplace=True)
y.index = pd.to_datetime(y.index)
y = y.resample('1M').mean()

from pylab import rcParams
import statsmodels.api as sm

"""#Time Series Component"""

# Aggregating the Time Series to a monthly scaled index
y = data[['Date','Close']].copy()
y.set_index('Date', inplace=True)
#y.index = pd.to_datetime(y.index)
y = y.resample('1M').mean()

# Setting rcparams
rcParams['figure.figsize'] = 15, 12
rcParams['axes.labelsize'] = 15
rcParams['ytick.labelsize'] = 12
rcParams['xtick.labelsize'] = 10

# Using statistical tools of statsmodel library
decomposition = sm.tsa.seasonal_decompose(y, model='multiplicative')
decomp = decomposition.plot()
decomp.suptitle('Close decomposition', fontsize=15)

"""#Checking For Stationarity

A stationary Time Series is one whose properties do not depend on the time at which the series is observed. Thus, time series with trends, or with seasonality, are not stationary

A time series with cyclic behavior (but with no trend or seasonality) is stationary.

Methods to Check the Stationarity

statistical tests called Unit Root Tests like Augmented Dickey Fuller test (ADF Test)
Kwiatkowski-Phillips-Schmidt-Shin â€” KPSS test (trend stationary)
Philips Perron test (PP Test).
The most commonly used is the ADF test, where the null hypothesis is that the time series possesses a unit root (or random walk with drift) and is non-stationary. So, if the P-Value in ADF test is less than the significance level (0.05), you reject the null hypothesis and the series is stationary.

#Augmented Dicky Fuller Test
"""

from statsmodels.tsa.stattools import adfuller

"""#Checking for Stationarity"""

def adf_test(series, title=''):
    """
    Pass in a time series and an optional title, returns an ADF report
    """
    print('Augmented Dickey-Fuller Test: {}'.format(title))
    # .dropna() handles differenced data
    result = adfuller(series.dropna(),autolag='AIC') 
    
    labels = ['ADF test statistic','p-value','# lags used','# observations']
    out = pd.Series(result[0:4],index=labels)

    for key,val in result[4].items():
        out['critical value ({})'.format(key)]=val
        
    # .to_string() removes the line "dtype: float64"
    print(out.to_string())          
    
    if result[1] <= 0.05:
        print("Strong evidence against the null hypothesis")
        print("Reject the null hypothesis")
        print("Data has no unit root and is stationary")
    else:
        print("Weak evidence against the null hypothesis")
        print("Fail to reject the null hypothesis")
        print("Data has a unit root and is non-stationary")
        
# Aggregating the Time Series to a monthly scaled index
y = data[['Date','Close']].copy()
y.set_index('Date', inplace=True)
y.index = pd.to_datetime(y.index)
#y = y.resample('M').mean()
        
adf_test(y['Close'],title='')

"""#Converting Non-Stationarity data to Stationary data
There are several ways to make a Time Series stationary

Difference the series once or more times (subtracting the next value by the current value)

Take the log of the series (helps to stabilize the variance of a time series.)

Take the nth root of the series

Combinations of the above

#Day Differencing
"""

y = data[['Date','Close']].copy()
y = y.set_index(['Date'])
y[:5]

y["diff1"] = y['Close'] - y['Close'].shift()

y

y = data[['Date','Close']].copy()
y = y.set_index(['Date'])
y[:5].diff(2)

pd.concat([y['Close'], y['Close'].diff(2), y['Close'].diff()],axis=1).plot(figsize=(12,8))

plt.figure(figsize=(12,6))
plt.plot(y.diff(2),label="diff(2)")
plt.plot(y.diff(),label="diff(1)")
plt.legend()

from statsmodels.tsa.statespace.tools import diff

fig, ax = plt.subplots(nrows=2, ncols=2,figsize=(15, 11))

y['CloseDiff1'] = diff(y['Close'],k_diff=1)
y['CloseDiff2'] = diff(y['Close'],k_diff=2)
y['CloseDiff3'] = diff(y['Close'],k_diff=3)

y['Close'].plot(title="Initial Data",ax=ax[0][0]).autoscale(axis='x',tight=True);
y['CloseDiff1'].plot(title="First Difference Data",ax=ax[0][1]).autoscale(axis='x',tight=True);
y['CloseDiff2'].plot(title="Second Difference Data",ax=ax[1][0]).autoscale(axis='x',tight=True);
y['CloseDiff3'].plot(title="Third Difference Data",ax=ax[1][1]).autoscale(axis='x',tight=True);

fig.autofmt_xdate()

y

"""#Checking Staionarity for Diffrenced data"""

# check for stationarity
def adf_test(series, title=''):
    """
    Pass in a time series and an optional title, returns an ADF report
    """
    print('Augmented Dickey-Fuller Test: {}'.format(title))
    # .dropna() handles differenced data
    result = adfuller(series.dropna(),autolag='AIC') 
    
    labels = ['ADF test statistic','p-value','# lags used','# observations']
    out = pd.Series(result[0:4],index=labels)

    for key,val in result[4].items():
        out['critical value ({})'.format(key)]=val
        
    # .to_string() removes the line "dtype: float64"
    print(out.to_string())          
    
    if result[1] <= 0.05:
        print("Strong evidence against the null hypothesis")
        print("Reject the null hypothesis")
        print("Data has no unit root and is stationary")
    else:
        print("Weak evidence against the null hypothesis")
        print("Fail to reject the null hypothesis")
        print("Data has a unit root and is non-stationary")
        

adf_test(y['CloseDiff1'],title='')

"""Here wwe Converted data into stationary

#ACF and PACF plots

Auto Correlation function and Partial Auto Correlation Function

ACF is nothing but Correlatio between "y" i,e. 'Close' and its own lags

PACF tells you, The strenght of relationship between "y" and lags of "y" after removing the effects of Intermediate lags
"""

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

f, ax = plt.subplots(nrows=2, ncols=1, figsize=(14, 10))
plot_acf(data['Close'],lags=60, ax=ax[0])
plot_pacf(data['Close'],lags=60, ax=ax[1], method='ols')

ax[1].annotate('Strong correlation at lag = 1D', xy=(1, 0.6),  xycoords='data',
            xytext=(0.17, 0.75), textcoords='axes fraction',
            arrowprops=dict(color='red', shrink=0.05, width=1))


plt.tight_layout()
plt.show()

"""The lags which are crossing the significant area are having a statistically significant correlation with "y"

There is significant spike at lag 1 in athe ACF, but none beyond lag 1, so we can choose q value as 1

There is significant spike at lag 1 in athe PACF, but none beyond lag 1, so we can choose p value as 1

#Seasonal Differencing

Quarterly Differencing
"""

# Aggregating the Time Series to a monthly scaled index
y = data[['Date','Close']].copy()
y.set_index('Date', inplace=True)
y.index = pd.to_datetime(y.index)
y = y.resample('Q').mean()

plt.figure(figsize=(12,6))
plt.plot(y.diff(2),label="diff(2)")
plt.plot(y.diff(),label="diff(1)")
plt.legend()

f, ax = plt.subplots(nrows=2, ncols=1, figsize=(12, 8))
plot_acf(y["Close"].diff().dropna(),lags=10, ax=ax[0])
plot_pacf(y['Close'].diff().dropna(),lags=10, ax=ax[1], method='ols')

ax[1].annotate('Strong correlation at lag = 1Q', xy=(1, 0.6),  xycoords='data',
            xytext=(0.17, 0.75), textcoords='axes fraction',
            arrowprops=dict(color='red', shrink=0.05, width=1))


plt.tight_layout()
plt.show()

"""#Monthly Differencing"""

# Aggregating the Time Series to a monthly scaled index
y = data[['Date','Close']].copy()
y.set_index('Date', inplace=True)
y.index = pd.to_datetime(y.index)
y = y.resample('M').mean()

plt.figure(figsize=(12,6))
plt.plot(y.diff(2),label="diff(2)")
plt.plot(y.diff(),label="diff(1)")
plt.legend()

"""#Yearly Differencing"""

# Aggregating the Time Series to a monthly scaled index
y = data[['Date','Close']].copy()
y.set_index('Date', inplace=True)
y.index = pd.to_datetime(y.index)
y = y.resample('A').mean()

plt.figure(figsize=(12,6))
plt.plot(y.diff(2),label="diff(2)")
plt.plot(y.diff(),label="diff(1)")
plt.legend()

data

"""#Splitting the Data"""

# Split data into train and validation set 90/10
data_train, data_test = data[:int(len(data)*0.90)], data[int(len(data)*0.90):]

# Index disappeared, put them back
data_test = data_test.set_index('Date', drop=False)
data_train = data_train.set_index('Date', drop=False)

# Line plot
fig, ax = plt.subplots(figsize=(15, 6))
sns.lineplot(data_train['Date'], data_train['Close'], color = 'black')
sns.lineplot(data_test['Date'], data_test['Close'], color = 'blue')

# Formatting
ax.set_title('Close Price', fontsize = 15, loc='center')
ax.set_xlabel('Year', fontsize = 15)
ax.set_ylabel('Price', fontsize = 15)
plt.tick_params(axis='y', which='major', labelsize=12)
plt.tick_params(axis='x', which='major', labelsize=12)
plt.legend(loc='upper right' ,labels = ('train', 'test'))

data_train.tail(1)

"""#ARIMA Model"""

from statsmodels.tsa.arima.model import ARIMA

model = ARIMA(data_train['Close'], order = (1, 1, 1))   #p = 1, d = 1, q = 1
fitted = model.fit()
print(fitted.summary())

"""Here,

p is the order of the AR term, It refers to the number of lags of Y to be used as predictors.

q is the order of the MA term, It refers to the number of lagged forecast errors that should go into the ARIMA Model.

d is the number of differencing required to make the time series stationary

If a time series, has seasonal patterns, then you need to add seasonal terms and it becomes SARIMA, short for â€˜Seasonal ARIMAâ€™. More on that once we finish ARIMA.
"""

data.shape[0]-data_train.shape[0]

data_train.shape

data_test.shape

df = pd.DataFrame({
    'predicted' :fitted.forecast(202, alpha=0.05),
    'Date' : data_test.index
    })
fc=df.set_index(["Date"])
fc

fc.plot()

plt.figure(figsize=(12,5), dpi=100)
plt.plot(data_train['Close'], label='training')
plt.plot(data_train['Close'], color = 'black', label='train Stock Price')
plt.plot(data_test['Close'], color = 'blue', label='test Stock Price')
plt.plot(fc, color = 'red',label='Predicted Stock Price')

plt.title('Apple Stock Price Prediction')
plt.xlabel('Date')
plt.ylabel('Actual Stock Price')
plt.legend(loc='upper left', fontsize=8)
plt.show()

fitted.plot_diagnostics(lags=30, figsize=(16,12))
plt.show()

y=data.copy()
y = y.set_index(["Date"], drop=True)

# Plot
fig, axes = plt.subplots(2, 1, figsize=(10,5), dpi=100, sharex=True)


# Usual Differencing
axes[0].plot(y['Close'], label='Original Series')
axes[0].plot(y["Close"].diff(1), label='Usual Differencing')
axes[0].set_title('Usual Differencing')
axes[0].legend(loc='upper left', fontsize=10)


# Seasinal Dei
axes[1].plot(y["Close"], label='Original Series')
axes[1].plot(y["Close"].diff(63), label='Seasonal Differencing', color='green')
axes[1].set_title('Seasonal Differencing')
plt.legend(loc='upper left', fontsize=10)
plt.suptitle('APPL stocks', fontsize=16)
plt.show()

# Plot
fig, axes = plt.subplots(2, 1, figsize=(10,5), dpi=100, sharex=True)

# Usual Differencing
axes[0].plot(y['Close'], label='Original Series')
axes[0].plot(y["Close"].diff(1), label='Usual Differencing')
axes[0].set_title('Usual Differencing')
axes[0].legend(loc='upper left', fontsize=10)


# Seasinal Differencing
axes[1].plot(y["Close"], label='Original Series')
axes[1].plot(y["Close"].diff(252), label='Seasonal Differencing', color='green')
axes[1].set_title('Seasonal Differencing')
plt.legend(loc='upper left', fontsize=10)
plt.suptitle('APPL stocks', fontsize=16)
plt.show()

"""#SARIMA model for Quarterly Seasonality"""

import statsmodels.api as sm

smodel = sm.tsa.statespace.SARIMAX(data_train['Close'],
                                            order=(1,1,1),
                                            seasonal_order=(1,1,1,63),
                                            enforce_stationarity=False,
                                            enforce_invertibility=False)
q_results = smodel.fit()
q_results.summary()

"""
Covariance matrix calculated using the outer product of gradients (complex-step)"""

df = pd.DataFrame({
    'predicted' :q_results.forecast(202, alpha=0.05),
    'Date' : data_test.index
    })
q_fc=df.set_index(["Date"])
q_fc

plt.figure(figsize=(12,5), dpi=100)
plt.plot(data_train['Close'], label='training')
plt.plot(data_train['Close'], color = 'black', label='train Stock Price')
plt.plot(data_test['Close'], color = 'blue', label='test Stock Price')
plt.plot(q_fc, color = 'red',label='Predicted Stock Price')

plt.title('Apple Stock Price Prediction')
plt.xlabel('Date')
plt.ylabel('Actual Stock Price')
plt.legend(loc='upper left', fontsize=8)
plt.show()

plt.figure(figsize=(12,10), dpi=100)
#plt.plot(data_train['Close'], label='training')
#plt.plot(data_train['Close'], color = 'black', label='train Stock Price')
plt.plot(data_test['Close'], color = 'blue', label='test Stock Price')
plt.plot(q_fc, color = 'red',label='Predicted Stock Price')

plt.title('Apple Stock Price Prediction')
plt.xlabel('Date')
plt.ylabel('Actual Stock Price')
plt.legend(loc='upper left', fontsize=8)
plt.show()

y=data_train.copy()
y = y.set_index(["Date"], drop=True)
y = y.resample('M').mean()
y

"""#SARIMA Model for Yearly Seasonality"""

smodel = sm.tsa.statespace.SARIMAX(y['Close'],
                                            order=(1,1,1),
                                            seasonal_order=(1,1,1,126),
                                            enforce_stationarity=False,
                                            enforce_invertibility=False)
results = smodel.fit()

results.summary()

""" Covariance matrix calculated using the outer product of gradients (complex-step)"""

df = pd.DataFrame({
    'predicted' :results.forecast(202, alpha=0.05),
    'Date' : data_test.index
    })
fc=df.set_index(["Date"])
fc

plt.figure(figsize=(12,5), dpi=100)
plt.plot(data_train['Close'], label='training')
plt.plot(data_train['Close'], color = 'black', label='train Stock Price')
plt.plot(data_test['Close'], color = 'blue', label='test Stock Price')
plt.plot(fc, color = 'red',label='Predicted Stock Price')

plt.title('Apple Stock Price Prediction')
plt.xlabel('Date')
plt.ylabel('Actual Stock Price')
plt.legend(loc='upper left', fontsize=8)
plt.show()

plt.figure(figsize=(12,10), dpi=100)
#plt.plot(data_train['Close'], label='training')
#plt.plot(data_train['Close'], color = 'black', label='train Stock Price')
plt.plot(data_test['Close'], color = 'blue', label='test Stock Price')
plt.plot(fc, color = 'red',label='Predicted Stock Price')

plt.title('Apple Stock Price Prediction')
plt.xlabel('Date')
plt.ylabel('Actual Stock Price')
plt.legend(loc='upper left', fontsize=8)
plt.show()